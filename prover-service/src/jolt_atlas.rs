//! Jolt Atlas zkML Integration
//!
//! This module provides the integration layer between the prover service
//! and the Jolt Atlas zkML proving system.
//!
//! ## Architecture
//!
//! Jolt Atlas extends the a16z Jolt zkVM with specialized precompiles for
//! machine learning operations. Instead of proving RISC-V execution, it
//! proves ONNX model inference directly using:
//!
//! - Lookup tables for non-linear operations (ReLU, Softmax, etc.)
//! - Sumcheck protocols for matrix-vector multiplication
//! - Sparse polynomial commitments for efficiency
//!
//! ## Usage
//!
//! When the `real-prover` feature is enabled, this module uses the actual
//! Jolt Atlas proving system. Otherwise, it falls back to mock proofs.

use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::path::Path;

/// Proof generated by Jolt Atlas
#[derive(Clone, Serialize, Deserialize)]
pub struct JoltAtlasProof {
    /// Version of the proof format
    pub version: u8,

    /// Prover identifier
    pub prover_id: String,

    /// Commitment to the ONNX model weights
    pub model_commitment: String,

    /// Hash of input features
    pub input_hash: String,

    /// Hash of output predictions
    pub output_hash: String,

    /// The actual inference output
    pub outputs: Vec<f32>,

    /// Timestamp of proof generation
    pub timestamp: u64,

    /// The SNARK proof data
    pub proof_data: ProofData,
}

/// SNARK proof components
#[derive(Clone, Serialize, Deserialize)]
pub struct ProofData {
    /// Polynomial commitments
    pub commitments: Vec<String>,

    /// Sumcheck proof for matrix operations
    pub sumcheck_proof: String,

    /// Lookup argument proof
    pub lookup_proof: String,

    /// Opening proofs
    pub opening_proofs: Vec<String>,
}

/// Verification result
#[derive(Debug)]
pub struct VerificationResult {
    pub valid: bool,
    pub error: Option<String>,
}

/// Jolt Atlas prover trait
///
/// This trait defines the interface for zkML proof generation.
/// Implement this trait with either the mock prover or the real
/// Jolt Atlas prover depending on the feature flags.
pub trait ZkmlProver: Send + Sync {
    /// Generate a proof for ONNX model inference
    fn prove(
        &self,
        model_commitment: &str,
        inputs: &[f32],
        outputs: &[f32],
    ) -> Result<JoltAtlasProof>;

    /// Verify a proof
    fn verify(&self, proof: &JoltAtlasProof) -> Result<VerificationResult>;

    /// Get prover identifier
    fn prover_id(&self) -> &str;
}

// ============================================================================
// Mock Prover Implementation (default)
// ============================================================================

#[cfg(feature = "mock-prover")]
pub mod mock {
    use super::*;
    use std::time::{SystemTime, UNIX_EPOCH};

    /// Mock prover for development and testing
    pub struct MockProver;

    impl MockProver {
        pub fn new() -> Self {
            Self
        }
    }

    impl Default for MockProver {
        fn default() -> Self {
            Self::new()
        }
    }

    impl ZkmlProver for MockProver {
        fn prove(
            &self,
            model_commitment: &str,
            inputs: &[f32],
            outputs: &[f32],
        ) -> Result<JoltAtlasProof> {
            let input_hash = hash_floats(inputs);
            let output_hash = hash_floats(outputs);

            let timestamp = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs();

            // Generate deterministic mock proof data
            let seed = generate_proof_seed(model_commitment, &input_hash, &output_hash);

            let proof_data = ProofData {
                commitments: vec![
                    hex::encode(&seed[0..32]),
                    hex::encode(&seed[32..64]),
                ],
                sumcheck_proof: hex::encode(hash_with_domain(&seed, b"sumcheck")),
                lookup_proof: hex::encode(hash_with_domain(&seed, b"lookup")),
                opening_proofs: vec![
                    hex::encode(hash_with_domain(&seed, b"opening_0")),
                    hex::encode(hash_with_domain(&seed, b"opening_1")),
                ],
            };

            Ok(JoltAtlasProof {
                version: 1,
                prover_id: "jolt-atlas-mock-v1".to_string(),
                model_commitment: model_commitment.to_string(),
                input_hash,
                output_hash,
                outputs: outputs.to_vec(),
                timestamp,
                proof_data,
            })
        }

        fn verify(&self, proof: &JoltAtlasProof) -> Result<VerificationResult> {
            // Verify version
            if proof.version != 1 {
                return Ok(VerificationResult {
                    valid: false,
                    error: Some("Invalid proof version".to_string()),
                });
            }

            // Verify prover ID
            if proof.prover_id != "jolt-atlas-mock-v1" {
                return Ok(VerificationResult {
                    valid: false,
                    error: Some("Unknown prover".to_string()),
                });
            }

            // Verify proof data consistency
            let expected_seed = generate_proof_seed(
                &proof.model_commitment,
                &proof.input_hash,
                &proof.output_hash,
            );

            let expected_sumcheck = hex::encode(hash_with_domain(&expected_seed, b"sumcheck"));
            if proof.proof_data.sumcheck_proof != expected_sumcheck {
                return Ok(VerificationResult {
                    valid: false,
                    error: Some("Sumcheck proof mismatch".to_string()),
                });
            }

            let expected_lookup = hex::encode(hash_with_domain(&expected_seed, b"lookup"));
            if proof.proof_data.lookup_proof != expected_lookup {
                return Ok(VerificationResult {
                    valid: false,
                    error: Some("Lookup proof mismatch".to_string()),
                });
            }

            Ok(VerificationResult {
                valid: true,
                error: None,
            })
        }

        fn prover_id(&self) -> &str {
            "jolt-atlas-mock-v1"
        }
    }

    fn generate_proof_seed(model_commitment: &str, input_hash: &str, output_hash: &str) -> Vec<u8> {
        let mut hasher = Sha256::new();
        hasher.update(model_commitment.as_bytes());
        hasher.update(input_hash.as_bytes());
        hasher.update(output_hash.as_bytes());
        let h1 = hasher.finalize();

        let mut hasher2 = Sha256::new();
        hasher2.update(&h1);
        hasher2.update(b"proof_seed");
        let h2 = hasher2.finalize();

        [h1.as_slice(), h2.as_slice()].concat()
    }

    fn hash_with_domain(seed: &[u8], domain: &[u8]) -> Vec<u8> {
        let mut hasher = Sha256::new();
        hasher.update(seed);
        hasher.update(domain);
        hasher.finalize().to_vec()
    }
}

// ============================================================================
// Real Jolt Atlas Prover (calls the authorization_json binary)
// ============================================================================

pub mod real {
    use super::*;
    use std::path::PathBuf;
    use std::process::Command;
    use std::time::{SystemTime, UNIX_EPOCH};

    /// JSON output from the authorization_json binary
    #[derive(Deserialize)]
    struct BinaryOutput {
        success: bool,
        decision: String,
        confidence: f32,
        proof_hash: String,
        proof_size: usize,
        prove_time_ms: u64,
        verify_time_ms: u64,
        input_features: InputFeatures,
        error: Option<String>,
    }

    #[derive(Deserialize)]
    struct InputFeatures {
        budget: usize,
        trust: usize,
        amount: usize,
        category: usize,
        velocity: usize,
        day: usize,
        time: usize,
        risk: usize,
    }

    /// Real Jolt Atlas prover using the authorization_json binary
    ///
    /// This implementation calls the precompiled Jolt Atlas binary
    /// to generate real zkML proofs.
    pub struct RealProver {
        binary_path: PathBuf,
        working_dir: PathBuf,
    }

    impl RealProver {
        pub fn new() -> Result<Self> {
            // Find the binary and model files
            let base_dir = std::env::current_dir()?;
            let jolt_dir = base_dir.join("jolt-atlas");

            let binary_path = jolt_dir.join("bin/authorization_json");
            if !binary_path.exists() {
                return Err(anyhow!(
                    "Jolt Atlas binary not found at {}. Run setup first.",
                    binary_path.display()
                ));
            }

            // Check for model files
            let model_dir = jolt_dir.join("models/authorization");
            if !model_dir.exists() {
                return Err(anyhow!(
                    "Jolt Atlas model directory not found at {}",
                    model_dir.display()
                ));
            }

            tracing::info!(
                "Initialized real Jolt Atlas prover with binary at {}",
                binary_path.display()
            );

            Ok(Self {
                binary_path,
                working_dir: jolt_dir,
            })
        }

        /// Convert float inputs to authorization features
        ///
        /// The authorization model expects 8 features:
        /// [budget, trust, amount, category, velocity, day, time, risk]
        fn inputs_to_features(&self, inputs: &[f32]) -> Result<(usize, usize, usize, usize, usize, usize, usize, usize)> {
            if inputs.len() < 8 {
                // Use defaults for missing features
                let budget = inputs.get(0).map(|v| *v as usize).unwrap_or(10);
                let trust = inputs.get(1).map(|v| *v as usize).unwrap_or(5);
                let amount = inputs.get(2).map(|v| *v as usize).unwrap_or(5);
                let category = inputs.get(3).map(|v| *v as usize).unwrap_or(0);
                let velocity = inputs.get(4).map(|v| *v as usize).unwrap_or(2);
                let day = inputs.get(5).map(|v| *v as usize).unwrap_or(1);
                let time = inputs.get(6).map(|v| *v as usize).unwrap_or(1);
                let risk = inputs.get(7).map(|v| *v as usize).unwrap_or(0);
                return Ok((budget, trust, amount, category, velocity, day, time, risk));
            }

            Ok((
                inputs[0] as usize,
                inputs[1] as usize,
                inputs[2] as usize,
                inputs[3] as usize,
                inputs[4] as usize,
                inputs[5] as usize,
                inputs[6] as usize,
                inputs[7] as usize,
            ))
        }
    }

    impl ZkmlProver for RealProver {
        fn prove(
            &self,
            model_commitment: &str,
            inputs: &[f32],
            _outputs: &[f32],
        ) -> Result<JoltAtlasProof> {
            let (budget, trust, amount, category, velocity, day, time, risk) =
                self.inputs_to_features(inputs)?;

            tracing::info!(
                "Generating real zkML proof with features: budget={}, trust={}, amount={}, category={}, velocity={}, day={}, time={}, risk={}",
                budget, trust, amount, category, velocity, day, time, risk
            );

            // Call the Jolt Atlas binary
            let output = Command::new(&self.binary_path)
                .args([
                    budget.to_string(),
                    trust.to_string(),
                    amount.to_string(),
                    category.to_string(),
                    velocity.to_string(),
                    day.to_string(),
                    time.to_string(),
                    risk.to_string(),
                ])
                .current_dir(&self.working_dir)
                .output()
                .map_err(|e| anyhow!("Failed to execute Jolt Atlas binary: {}", e))?;

            if !output.status.success() {
                let stderr = String::from_utf8_lossy(&output.stderr);
                return Err(anyhow!("Jolt Atlas binary failed: {}", stderr));
            }

            // Parse the JSON output (find the JSON line in stdout)
            let stdout = String::from_utf8_lossy(&output.stdout);
            let json_line = stdout
                .lines()
                .find(|line| line.trim().starts_with('{') && line.contains("\"success\""))
                .ok_or_else(|| anyhow!("No JSON output from Jolt Atlas binary"))?;

            let binary_output: BinaryOutput = serde_json::from_str(json_line)
                .map_err(|e| anyhow!("Failed to parse Jolt Atlas output: {}", e))?;

            if !binary_output.success {
                return Err(anyhow!(
                    "Jolt Atlas proof generation failed: {}",
                    binary_output.error.unwrap_or_default()
                ));
            }

            let input_hash = hash_floats(inputs);
            let output_hash = format!("0x{}", binary_output.proof_hash);

            let timestamp = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap()
                .as_secs();

            // Decision to output values
            let decision_value = if binary_output.decision == "AUTHORIZED" { 1.0 } else { 0.0 };
            let confidence = binary_output.confidence / 100.0;

            let proof_data = ProofData {
                commitments: vec![binary_output.proof_hash.clone()],
                sumcheck_proof: format!("real:{}", binary_output.prove_time_ms),
                lookup_proof: format!("verified:{}", binary_output.verify_time_ms),
                opening_proofs: vec![
                    format!("size:{}", binary_output.proof_size),
                    format!("decision:{}", binary_output.decision),
                ],
            };

            tracing::info!(
                "Generated real zkML proof: decision={}, confidence={:.1}%, prove_time={}ms, verify_time={}ms",
                binary_output.decision,
                binary_output.confidence,
                binary_output.prove_time_ms,
                binary_output.verify_time_ms
            );

            Ok(JoltAtlasProof {
                version: 2, // Version 2 = real prover
                prover_id: "jolt-atlas-real-v1".to_string(),
                model_commitment: model_commitment.to_string(),
                input_hash,
                output_hash,
                outputs: vec![1.0 - confidence, confidence], // [deny_prob, authorize_prob]
                timestamp,
                proof_data,
            })
        }

        fn verify(&self, proof: &JoltAtlasProof) -> Result<VerificationResult> {
            // The binary already verifies during proof generation
            // For external verification, we check the proof structure

            if proof.version != 2 {
                return Ok(VerificationResult {
                    valid: false,
                    error: Some("Invalid proof version for real prover".to_string()),
                });
            }

            if proof.prover_id != "jolt-atlas-real-v1" {
                return Ok(VerificationResult {
                    valid: false,
                    error: Some("Unknown prover ID".to_string()),
                });
            }

            // Check that proof data contains verification timing (indicating it was verified)
            let has_verify_time = proof.proof_data.lookup_proof.starts_with("verified:");
            if !has_verify_time {
                return Ok(VerificationResult {
                    valid: false,
                    error: Some("Proof missing verification data".to_string()),
                });
            }

            Ok(VerificationResult {
                valid: true,
                error: None,
            })
        }

        fn prover_id(&self) -> &str {
            "jolt-atlas-real-v1"
        }
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

/// Hash a slice of floats
pub fn hash_floats(values: &[f32]) -> String {
    let mut hasher = Sha256::new();
    for v in values {
        hasher.update(v.to_le_bytes());
    }
    format!("0x{}", hex::encode(hasher.finalize()))
}

/// Compute model commitment from ONNX bytes
pub fn compute_model_commitment(model_bytes: &[u8]) -> String {
    let mut hasher = Sha256::new();
    hasher.update(model_bytes);
    format!("0x{}", hex::encode(hasher.finalize()))
}

/// Serialize a proof to base64
pub fn serialize_proof(proof: &JoltAtlasProof) -> Result<String> {
    let json = serde_json::to_vec(proof)?;
    Ok(base64::Engine::encode(&base64::engine::general_purpose::STANDARD, json))
}

/// Deserialize a proof from base64
pub fn deserialize_proof(encoded: &str) -> Result<JoltAtlasProof> {
    let json = base64::Engine::decode(&base64::engine::general_purpose::STANDARD, encoded)?;
    let proof: JoltAtlasProof = serde_json::from_slice(&json)?;
    Ok(proof)
}

// ============================================================================
// Factory Function
// ============================================================================

/// Create the appropriate prover based on features
pub fn create_prover() -> Result<Box<dyn ZkmlProver>> {
    #[cfg(feature = "real-prover")]
    {
        tracing::info!("Creating real Jolt Atlas prover");
        return Ok(Box::new(real::RealProver::new()?));
    }

    #[cfg(all(feature = "mock-prover", not(feature = "real-prover")))]
    {
        tracing::info!("Creating mock Jolt Atlas prover");
        Ok(Box::new(mock::MockProver::new()))
    }

    #[cfg(not(any(feature = "mock-prover", feature = "real-prover")))]
    {
        Err(anyhow!("No prover feature enabled"))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hash_floats_deterministic() {
        let values = vec![1.0, 2.0, 3.0];
        let hash1 = hash_floats(&values);
        let hash2 = hash_floats(&values);
        assert_eq!(hash1, hash2);
    }

    #[test]
    fn test_model_commitment() {
        let model_bytes = b"fake onnx model data";
        let commitment = compute_model_commitment(model_bytes);
        assert!(commitment.starts_with("0x"));
        assert_eq!(commitment.len(), 66); // 0x + 64 hex chars
    }

    #[cfg(feature = "mock-prover")]
    #[test]
    fn test_mock_prover_roundtrip() {
        let prover = mock::MockProver::new();

        let model_commitment = "0x1234567890abcdef";
        let inputs = vec![1.0, 2.0, 3.0];
        let outputs = vec![0.9, 0.1];

        let proof = prover.prove(model_commitment, &inputs, &outputs).unwrap();
        let result = prover.verify(&proof).unwrap();

        assert!(result.valid);
    }
}
